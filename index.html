<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>專業即時逐字稿工具</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #f4f4f9;
        }
        h1 {
            color: #333;
        }
        /* 優化顯示區域的樣式 */
        .transcript-container {
            width: 80%;
            max-width: 800px;
            height: 45vh;
            margin-bottom: 20px;
            border: 1px solid #ccc;
            border-radius: 8px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow-y: scroll; /* 允許垂直捲動 */
            padding: 15px;
        }
        #transcript {
            white-space: pre-wrap; /* 自動換行 */
            word-wrap: break-word; /* 斷詞 */
            font-size: 16px;
            line-height: 1.6;
            margin: 0;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
        }
        .interim {
            color: #888;
        }
        .volume-meter {
            width: 80%;
            max-width: 800px;
            height: 20px;
            background-color: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
            border: 1px solid #ccc;
        }
        .volume-level {
            height: 100%;
            width: 0%;
            background-color: #4CAF50;
            transition: width 0.1s ease-out;
        }
        .controls {
            display: flex;
            gap: 15px;
        }
        button {
            padding: 12px 25px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            color: white;
            transition: background-color 0.3s ease;
        }
        #controlBtn { background-color: #007bff; }
        #controlBtn:hover { background-color: #0056b3; }
        #exportBtn { background-color: #28a745; }
        #exportBtn:hover { background-color: #218838; }
        #exportBtn:disabled { background-color: #9E9E9E; cursor: not-allowed; }
    </style>
</head>
<body>
    <h1>專業即時逐字稿工具</h1>
    
    <div class="transcript-container" id="transcriptContainer">
        <pre id="transcript"></pre>
    </div>
    
    <div class="volume-meter">
        <div class="volume-level" id="volumeLevel"></div>
    </div>
    
    <div class="controls">
        <button id="controlBtn">開始辨識</button>
        <button id="exportBtn" disabled>輸出逐字稿</button>
    </div>

    <script>
        const transcriptContainer = document.getElementById('transcriptContainer');
        const transcriptElement = document.getElementById('transcript');
        const controlBtn = document.getElementById('controlBtn');
        const exportBtn = document.getElementById('exportBtn');
        const volumeLevel = document.getElementById('volumeLevel');

        let startTime, endTime;
        let transcriptSegments = []; // 儲存帶時間戳的文字片段

        let audioContext, microphoneStream, analyser, animationFrameId;

        if ('webkitSpeechRecognition' in window) {
            const recognition = new webkitSpeechRecognition();
            let isRecognizing = false;
            let interim_transcript = '';

            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';

            recognition.onstart = () => {
                isRecognizing = true;
                controlBtn.textContent = '停止辨識';
                exportBtn.disabled = true;
                startTime = new Date();
                transcriptSegments = []; // 清空之前的紀錄
                // 增加一個開始標記
                transcriptSegments.push({ timestamp: startTime, text: '--- 錄音開始 ---' });
                updateTranscriptDisplay();
            };

            recognition.onerror = (event) => {
                console.error('語音辨識錯誤:', event.error);
                if (event.error === 'not-allowed') alert('您拒絕了麥克風權限。');
                stopAudioMeter();
            };

            recognition.onend = () => {
                isRecognizing = false;
                controlBtn.textContent = '開始辨識';
                endTime = new Date();
                if (transcriptSegments.length > 1) { // 至少要有一句內容
                    exportBtn.disabled = false;
                }
                stopAudioMeter();
            };

            recognition.onresult = (event) => {
                interim_transcript = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        // 這是核心：當一句話結束時，創建一個帶時間戳的物件
                        if (transcript.trim()) {
                           transcriptSegments.push({ timestamp: new Date(), text: transcript.trim() });
                        }
                    } else {
                        interim_transcript += transcript;
                    }
                }
                updateTranscriptDisplay();
            };
            
            function updateTranscriptDisplay() {
                // 從結構化資料生成顯示內容
                const finalContent = transcriptSegments.map(segment => {
                    return `${formatTime(segment.timestamp)} ${segment.text}`;
                }).join('\n');

                transcriptElement.innerHTML = `${finalContent}\n<span class="interim">${interim_transcript}</span>`;
                
                // 自動滾動到底部
                transcriptContainer.scrollTop = transcriptContainer.scrollHeight;
            }

            controlBtn.addEventListener('click', () => {
                if (isRecognizing) {
                    recognition.stop();
                } else {
                    startAudioMeter().then(() => {
                        recognition.start();
                    }).catch(err => {
                        console.error("無法啟動音訊偵測:", err);
                    });
                }
            });

            exportBtn.addEventListener('click', () => {
                if (!startTime || !endTime) return;
                
                // 從結構化資料生成檔案內容
                const textToSave = transcriptSegments.map(segment => {
                    return `${formatTime(segment.timestamp)} ${segment.text}`;
                }).join('\r\n'); // 使用 \r\n 換行，在 Windows 的記事本中格式更佳

                const fileName = createFileName(startTime, endTime);
                const blob = new Blob([textToSave], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                a.click();
                URL.revokeObjectURL(url);
            });

        } else {
            alert('您的瀏覽器不支援 Web Speech API，請使用最新版本的 Chrome 瀏覽器。');
        }

        // --- 時間格式化輔助函式 ---
        function formatTime(date) {
            const h = formatTwoDigits(date.getHours());
            const m = formatTwoDigits(date.getMinutes());
            const s = formatTwoDigits(date.getSeconds());
            return `[${h}:${m}:${s}]`;
        }

        // --- Web Audio API (音量 Bar) 相關函式 (不變) ---
        async function startAudioMeter() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                return Promise.reject('getUserMedia not supported');
            }
            microphoneStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(microphoneStream);
            source.connect(analyser);
            drawVolume();
        }

        function stopAudioMeter() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            if (microphoneStream) microphoneStream.getTracks().forEach(track => track.stop());
            if (audioContext && audioContext.state !== 'closed') audioContext.close();
            volumeLevel.style.width = '0%';
        }

        function drawVolume() {
            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteTimeDomainData(dataArray);
            let sumSquares = 0.0;
            for (const amplitude of dataArray) {
                const a = (amplitude / 128.0) - 1.0;
                sumSquares += a * a;
            }
            const rms = Math.sqrt(sumSquares / dataArray.length);
            const volume = Math.min(100, rms * 100 * 10);
            volumeLevel.style.width = volume + '%';
            animationFrameId = requestAnimationFrame(drawVolume);
        }

        // --- 其他輔助函式 (不變) ---
        function formatTwoDigits(n) { return n < 10 ? '0' + n : n; }
        function createFileName(start, end) {
            const date = `${start.getFullYear()}-${formatTwoDigits(start.getMonth() + 1)}-${formatTwoDigits(start.getDate())}`;
            const startTimeStr = `${formatTwoDigits(start.getHours())}-${formatTwoDigits(start.getMinutes())}-${formatTwoDigits(start.getSeconds())}`;
            const endTimeStr = `${formatTwoDigits(end.getHours())}-${formatTwoDigits(end.getMinutes())}-${formatTwoDigits(end.getSeconds())}`;
            return `${date}_${startTimeStr}_to_${endTimeStr}.txt`;
        }
    </script>
</body>
</html>
